Namespace DLM.Editor;

Helpers
    lower = ['a'..'z'];
    upper = ['A'..'Z'];
    digit = ['0'..'9'];
    all = [0 .. 0xFFFF];
    not_cr_lf = [all - [13 + 10]];
    short_comment = '//' not_cr_lf*;
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];
    long_comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

States
    normal, include;

Tokens
    {normal -> include} include = '#include';
    {include -> normal} file = '<' [all - '>']* '>';
    
    bool = 'true'|'false';
    number = digit+;
    
    principall = 'principal';
    typedef = 'typedef';
    struct = 'struct';
    
    while = 'while';
    if = 'if';
    else = 'else';
    return = 'return';
    
    this = 'this';
    caller = 'caller';
    
    identifier = (lower | upper) (lower | upper | digit | '_')*;
    
    if_acts_for = '-->?' | '?>';
    declassify_start = '<|';
    declassify_end = '|>';
    
    r_arrow = '->';
    l_arrow = '<-';
    
    compare = '==' | '>=' | '<=' | '>' | '<';
    
    assign = '=';
    
    underscore = '_';
    hat = '^';
    plus = '+';
    minus = '-';
    asterisk = '*';
    slash = '/';
    percent = '%';
    
    bang = '!';
    and = '&&';
    or = '||';
    
    period = '.';
    comma = ',';
    colon = ':';
    semicolon = ';';
    
    label_start = '{{';
    label_end = '}}';
    
    l_par = '(';
    r_par = ')';
    l_squ = '[';
    r_squ = ']';
    l_cur = '{';
    r_cur = '}';
    
    join = 0x2294;
    
    comment = short_comment | long_comment;
    whitespace = (' ' | 9 | 13 | 10)+;

Ignored Tokens
    whitespace, comment;

Token Syntax Highlight
    {comment} text: #393, italic;
    {if, else, while, return, typedef, struct} text: #00c, bold;
    {label_start, label_end, if_acts_for, declassify_start, declassify_end, r_arrow, join, principall, this, caller} text: #8d19aa, background: #e6e7fa, bold;
    {underscore, hat} text: #8d19aa, bold;

Abstract Syntax Tree
    root = P.include* principal_declaration* P.struct* statement*;
    
    include = file;
    
    principal_declaration = principal+;
    
    struct = identifier field* [name]:identifier;
    field
        = type identifier
        | {array} type identifier [size]:number
        ;
    
    statement
        = {declaration} type identifier expression?
        | {array_declaration} type identifier [size]:number
        | {assignment} identifier expression
        | {if_acts_for} claimant principal+ statement*
        | {if} expression statement*
        | {if_else} expression [if_statements]:statement* [else_statements]:statement*
        | {while} expression statement*
        | {function_declaration} type identifier [parameters]:function_parameter* statement*
        | {return} expression?
        ;
    function_parameter
        = type identifier
        ;
    type
        = [name]:identifier label?
        | {pointer} type asterisk
        ;
    claimant
        = {this} this
        | {caller} caller
        ;
Productions
    root = P.include* principal_declaration* P.struct* glstmt*;
    
    include = T.include file -> New include(file);
    
    principal_declaration = principall lprincipal semicolon -> New principal_declaration([lprincipal]);
    
    struct = typedef T.struct identifier l_cur field* r_cur [name]:identifier semicolon -> New struct(identifier, [field], name);
    field
        = type identifier semicolon -> New field(type, identifier)
        | {a} type identifier l_squ number r_squ semicolon -> New field.array(type, identifier, number)
        ;
    
    glstmt -> statement
        = {decl} type identifier semicolon -> New statement.declaration(type, identifier, Null)
        | {declval} type identifier assign expr semicolon -> New statement.declaration(type, identifier, expr)
        | {arr} type identifier l_squ number r_squ semicolon -> New statement.array_declaration(type, identifier, number)
        | {func} type identifier l_par fparams? r_par l_cur stmt* r_cur -> New statement.function_declaration(type, identifier, [fparams], [stmt])
        ;
    fparams -> function_parameter*
        = type identifier -> [New function_parameter(type, identifier)]
        | {tail} [t1]:type [i1]:identifier comma fparams -> [New function_parameter(t1, i1), fparams]
        ;
    stmt -> statement
        = {one} if l_par expr r_par block -> New statement.if(expr, [block])
        | {two} if l_par expr r_par [b1]:block2 else [b2]:block2 -> New statement.if_else(expr, [b1], [b2])
        | {w} while l_par expr r_par block -> New statement.while(expr, [block])
        | {act} claimant if_acts_for lprincipal block -> New statement.if_acts_for(claimant, [lprincipal], [block])
        | otherstmt -> otherstmt
        ;
    stmt2 -> statement
        = {two} if l_par expr r_par [b1]:block2 else [b2]:block2 -> New statement.if_else(expr, [b1], [b2])
        | {w} while l_par expr r_par block2 -> New statement.while(expr, [block2])
        | {act} claimant if_acts_for lprincipal block2 -> New statement.if_acts_for(claimant, [lprincipal], [block2])
        | otherstmt -> otherstmt
        ;
    otherstmt -> statement
        = {decl} type identifier semicolon -> New statement.declaration(type, identifier, Null)
        | {declval} type identifier assign expr semicolon -> New statement.declaration(type, identifier, expr)
        | {arr} type identifier l_squ number r_squ -> New statement.array_declaration(type, identifier, number)
        | {as} identifier assign expr semicolon -> New statement.assignment(identifier, expr)
        | {r} return expr? semicolon -> New statement.return(expr)
        ;
    type
        = identifier label? -> New type(identifier, label)
        | {pointer} type asterisk
        ;
    block -> statement*
        = {one} stmt -> [stmt]
        | {many} l_cur stmt* r_cur -> [stmt]
        ;
    block2 -> statement*
        = {one} stmt2 -> [stmt2]
        | {many} l_cur stmt* r_cur -> [stmt]
        ;
    claimant
        = {this} this
        | {caller} caller
        ;

Abstract Syntax Tree
    label
        = policy+
        ;
    policy
        = {variable} identifier
        | {principal} [owner]:principal [readers]:principal*
        | {lower} underscore
        | {upper} hat
        ;
    principal = identifier;
Productions
    label
        = label_start lpolicy label_end -> New label([lpolicy])
        ;
    policy
        = {id} identifier -> New policy.variable(identifier)
        | principal r_arrow lprincipal -> New policy.principal(principal, [lprincipal])
        | {one} principal r_arrow -> New policy.principal(principal, [])
        | {l} underscore -> New policy.lower(underscore)
        | {u} hat -> New policy.upper(hat)
        ;
    lpolicy -> policy+
        = policy -> [policy]
        | {tail} policy semicolon lpolicy -> [policy, lpolicy]
        | {tail2} policy join lpolicy -> [policy, lpolicy]
        ;
    principal = identifier;
    lprincipal -> principal+
        = principal -> [principal]
        | {tail} principal comma lprincipal -> [principal, lprincipal]
        ;

Abstract Syntax Tree
    expression
        = {and} [left]:expression [right]:expression
        | {or} [left]:expression [right]:expression
        | {not} expression
        | {comparison} [left]:expression compare [right]:expression
        
        | {element} expression element
        | {index} expression [index]:expression
        
        | {plus} [left]:expression [right]:expression
        | {minus} [left]:expression [right]:expression
        | {multiply} [left]:expression [right]:expression
        | {divide} [left]:expression [right]:expression
        | {modulo} [left]:expression [right]:expression
        | {negate} expression
        
        | {function_call} [function]:identifier [arguments]:expression*
        
        | {parenthesis} expression
        | {declassify} identifier label?
        | {identifier} identifier
        | {number} number
        | {boolean} bool
        ;
    element
        = identifier
        | {pointer} identifier
        ;

Productions
    expr -> expression
        = logicexpr -> logicexpr
        ;
    
    logicexpr -> expression
        = {and} logicterm and logicexpr -> New expression.and(logicterm, logicexpr)
        | {or} logicterm or logicexpr -> New expression.or(logicterm, logicexpr)
        | logicterm -> logicterm
        ;
    logicterm -> expression
        = {cmp} aritexpr compare logicterm -> New expression.comparison(aritexpr, compare, logicterm)
        | {not} bang aritexpr -> New expression.not(aritexpr)
        | aritexpr -> aritexpr
        ;
    
    aritexpr -> expression
        = {p} aritterm plus aritexpr -> New expression.plus(aritterm, aritexpr)
        | {m} aritterm minus aritexpr -> New expression.minus(aritterm, aritexpr)
        | {n} minus aritterm -> New expression.negate(aritterm)
        | aritterm -> aritterm
        ;
    aritterm -> expression
        = {m} aritfactor asterisk aritterm -> New expression.multiply(aritfactor, aritterm)
        | {d} aritfactor slash aritterm -> New expression.divide(aritfactor, aritterm)
        | {mod} aritfactor percent aritterm -> New expression.modulo(aritfactor, aritterm)
        | aritfactor -> aritfactor
        ;
    aritfactor -> expression
        = {e} aritfactor period identifier -> New expression.element(aritfactor, New element(identifier))
        | {p} aritfactor r_arrow identifier -> New expression.element(aritfactor, New element.pointer(identifier))
        | {i} aritfactor l_squ expr r_squ -> New expression.index(aritfactor, expr)
        | aritelem -> aritelem
        ;
    aritelem -> expression
        = {par} l_par expr r_par -> New expression.parenthesis(expr)
        | {func} funccall -> funccall
        | {n} number -> New expression.number(number)
        | {b} bool -> New expression.boolean(bool)
        | {id} identifier -> New expression.identifier(identifier)
        | {dec} declassify_start identifier declassify_end -> New expression.declassify(identifier, Null)
        | {dec2} declassify_start identifier comma label declassify_end -> New expression.declassify(identifier, label)
        ;

    funccall -> expression
        = identifier l_par funccallargs? r_par -> New expression.function_call(identifier, [funccallargs])
        ;
    funccallargs -> expression+
        = expr -> [expr]
        | {tail} expr comma funccallargs -> [expr, funccallargs]
        ;
